\renewcommand{\figurename}{Diagram}
\subsection{Merge Tracking}

Both Subversion and Git tracks merges performed in repository. There are differences, however in 
the granularity of the information being kept by Git and Subversion.
\\\\
\textbf{Subversion}: information on merge sources might be set on any path (file or directory) and might include not only
merge source paths, but also particular revisions.
\\\\
\textbf{Git}: merges are represented as merge commits. Git merge commit is a Git commit which has more than a single 
ancestor. Merge commit represents changes being merged from all of the ancestor's branches into the branch (or branches)
merge commit belongs to.
\\\\
\textbf{Translator}: merges are interpreted in terms of the source branches being merged into a 
target branch in particular commit or revision. This sort of interim interpretation allows Translator
to represent any merge commit in Git repository, as well as most common merge scenarios in Subversion repositories (merges
between branches).
\\\\
There are no means to represent some of the Subversion merge scenarios in terms of that interim language.
Such merges, which includes cherry-pick merges, merges on files or on non-branch directories are ignored by the Translator,
i.e. are translated to a regular Git commits with a single ancestor.

\subsubsection{Translation of the Git Merge Commit}

Git merge commit (commit with multiple ancestors) is translated into Subversion revision in two steps.
\begin{itemize}
\item Git commit is translated into Subversion revision, accordingly to the rules described in "Revisions and Commits" section.
This new revision, by definition, only affects single Subversion branch directory.
\item \textbf{svn:mergeinfo} property is updated on the affected Subversion branch directory so, that all merge
commit ancestor branches are considered to be merged into this very branch in this very revision.
\end{itemize}

Example of such translation is shown in the diagram \ref{simple_merge_git_to_svn}:

\begin{center}
\includegraphics[width=\textwidth]{img/diagrams/simple_merge_git_to_svn.pdf}%
\captionof{figure}{Git merge commit being translated to the change of svn:mergeinfo property.}
\label{simple_merge_git_to_svn}%
\end{center}

Revision \emph{6} is created as a result of commit \emph{f} translation. Then svn:mergeinfo property is updated on /branches/branch1 directory
(red arrow) to reflect merge of commits \emph{d} and \emph{e} made on /branches/branch2 into /branches/branch1. In this 
particular example svn:mergeinfo on /branhces/branch1 will be set to "/branches/branch2:4-5" value.
\\\\
Only commits made on the source (ancestor) branches are included into Subversion svn:mergeinfo, references to the commits on the same branch
are excluded. For instance, in the example above, svn:mergeinfo will not contain "/branches/branch1:1-2". Thus, translation of the merge commit with no common history will result in the same svn:mergeinfo being set in Subversion repository (see diagram \ref{simple_merge_branch_no_parent_git_to_svn})

\begin{center}
\includegraphics[width=\textwidth]{img/diagrams/simple_merge_branch_no_parent_git_to_svn.pdf}%
\captionof{figure}{Git merge commit being translated to the change of svn:mergeinfo property.}
\label{simple_merge_branch_no_parent_git_to_svn}%
\end{center}

\subsubsection{Translation of Subverion Merges}

Merge in Subversion is represented as a change of svn:mergeinfo property.
\\\\
Whenever such change of snv:mergeinfo is made on a branch directory and in 
such a way that svn:mergeinfo includes continuous ranges of revisions
made on one ore more branches (each range starting from the first revision of the branch), then that svn:mergeinfo modification is translated into a Git merge commit.
\\\\
Just like with translation of the Git merge commit into Subversion revision, 
translation in the opposite direction is performed in two steps:
\begin{itemize}
\item Git commit corresponding to the Subversion revision being translated is created accordingly 
to the rules described in "Revisions and Commits" section.
\item Additional parent commits are set on the created Git commit - one parent for each branch
referenced by Subversion svn:mergeinfo property.
\end{itemize}
Diagrams \ref{simple_merge_svn_to_git} and \ref{simple_merge_branch_no_parent_svn_to_git} provides
examples of svn:mergeinfo property (shown as a red arrow) change translation into Git Merge commit (commit \emph{f} on both
diagrams).

\begin{center}
\includegraphics[width=\textwidth]{img/diagrams/simple_merge_svn_to_git.pdf}%
\captionof{figure}{svn:mergeinfo property change being translated into merge commit creation.}
\label{simple_merge_svn_to_git}%
\end{center}

\begin{center}
\includegraphics[width=\textwidth]{img/diagrams/simple_merge_branch_no_parent_svn_to_git.pdf}%
\captionof{figure}{svn:mergeinfo property change being translated into merge commit creation.}
\label{simple_merge_branch_no_parent_svn_to_git}%
\end{center}

\subsubsection{Subversion Cherry-Pick Merges}

Subversion tracks merges of the individual revisions, feature also known as cherry-pick merges. 
Git has no means to express merge of the individual commits, hence changes of the svn:mergeinfo Subversion
property that result from the cherry-pick merge (i.e. changes that add individual revisions to the svn:mergeinfo) are
translated into the regular Git commit with a single parent commit (see diagram \ref{no_merge_commit_on_cherry_pick_svn_to_git}).
\begin{center}
\includegraphics[width=\textwidth]{img/diagrams/no_merge_commit_on_cherry_pick_svn_to_git.pdf}%
\captionof{figure}{Cherry-pick merge being translated to ordinary commit.}
\label{no_merge_commit_on_cherry_pick_svn_to_git}%
\end{center}

Eventually, a sequence of cherry-pick merges may result in svn:mergeinfo property referring to the 
continuous range of revisions on the merge source branch, starting from the first revision 
of that branch. This last modification of svn:mergeinfo is translated into Git merge commit, as 
shown on the diagrams \ref{merge_commit_on_double_cherry_pick_svn_to_git} and \ref{merge_commit_on_double_cherry_pick_branch_no_parent_svn_to_git}.

\begin{center}
\includegraphics[width=\textwidth]{img/diagrams/merge_commit_on_double_cherry_pick_svn_to_git.pdf}%
\captionof{figure}{A sequence of cherry-pick merges being translated to merge commit.}
\label{merge_commit_on_double_cherry_pick_svn_to_git}%
\end{center}

\begin{center}
\includegraphics[width=\textwidth]{img/diagrams/merge_commit_on_double_cherry_pick_branch_no_parent_svn_to_git.pdf}%
\captionof{figure}{A sequence of cherry-pick merges being translated to merge commit.}
\label{merge_commit_on_double_cherry_pick_branch_no_parent_svn_to_git}%
\end{center}

\subsubsection{Shelf Branches}

Git user is able to push an arbitrary number of commits at once. This set of Git commits might include Git merge commit, 
so that some of the Git commits in the set are arranged into the structure we call \emph{shelf}. In general, \emph{shelf}
translation includes:
\begin{itemize}
\item Creation of a temporary Subversion branch which correspond to the \emph{shelf};
\item Translation of the "shelved" commits into revisions on that temporary branch;
\item Translation of the merge commit into revision on the main branch, with svn:mergeinfo including all revisions
of the temporary branch.
\end{itemize}
Examples of \emph{shelf} translation are shown in the diagrams \ref{boat_merge_named_shelve_git_to_svn} and \ref{boat_merge_shelve_is_normal_branch_git_to_svn}.
In these examples it is possible to determine name of the temporary branch either because branch reference points directly to the 
last \emph{shelf} commit (diagram \ref{boat_merge_named_shelve_git_to_svn}) or to the commit originating from the \emph{shelf} (diagram \ref{boat_merge_shelve_is_normal_branch_git_to_svn}).
\begin{center}
\includegraphics[width=\textwidth]{img/diagrams/boat_merge_named_shelve_git_to_svn.pdf}%
\captionof{figure}{Merge of Git branch which is available from another branch being translated to a sequence of Subversion revisions.}
\label{boat_merge_named_shelve_git_to_svn}%
\end{center}
\begin{center}
\includegraphics[width=\textwidth]{img/diagrams/boat_merge_shelve_is_normal_branch_git_to_svn.pdf}%
\captionof{figure}{Merge of Git branch which is available from another branch being translated to a sequence of Subversion revisions.}
\label{boat_merge_shelve_is_normal_branch_git_to_svn}%
\end{center}

In certain cases, it is not possible to determine name of the temporary branch, as there is no branch reference pointing to
the \emph{shelved} commits. In such case Translator creates temporary branch named after last shelf commit author and 
deletes this temporary branch in the revision which corresponds to the merge commit (see diagram \ref{boat_merge_git_to_svn}). 
\\\\
To reduce clutter, anonymous temporary branch is created in the /shelves/ top-level Subversion directory, not in the /branches/ one where named branches reside.

\begin{center}
\includegraphics[width=\textwidth]{img/diagrams/boat_merge_git_to_svn.pdf}%
\captionof{figure}{Merge of anonymous Git branch being translated to a sequence of Subversion revisions.}
\label{boat_merge_git_to_svn}%
\end{center}

\subsubsection{Shelve Linearization}

It's common use case when multiple users performed modification and then merged all together at the main development branch of the remote repository. For this scenario every user's branch becomes a shelve. For Subversion users it is not a typical workflow, they are accustomed to have linear history of changes produced by different users.
\\\\
As an experimental feature for that case we introduce a shelve linearization approach depicted at diagram \ref{boat_merge_keep_history_linear_git_to_svn}.
\begin{center}
\includegraphics[width=\textwidth]{img/diagrams/boat_merge_keep_history_linear_git_to_svn.pdf}%
\captionof{figure}{Merge of Git branch which is available from another branch being translated to a sequence of Subversion revisions.}
\label{boat_merge_keep_history_linear_git_to_svn}%
\end{center}

If commit \emph{c} and a couple of commits \emph{d} and \emph{c} modified not intersecting set of files, then it is possible to imitate linear history for branch branch1. For that purpose Translator creates three revisions r6, r7, r8 instead of a single revision that would be mapped to merge commit \emph{f}.
\\\\
For every commit at shelve Translator generates a revision with synthetic cherry-pick merge of the revision mapped to this commit. Finally revision r8 is the revision corresponding to commit \emph{f} and also it has the history of the shelve within svn:mergeinfo property. Hence mapping commit \emph{f} to revision r8 is valid. Having these revisions at branch branch1 Subversion users see history of branch branch1 linear.
\\\\
Shelve linearization has a few drawbacks:
\begin{enumerate}
\compactlist
	\item Main branch and shelve must not modify the same file, otherwise the approach is not applicable.
	\item At revisions r7 and r8 there could appear build failures since at this revision branch1 state is generated by Translator with no additional checks.
	\item This approach violates commits to revision mapping, since \emph{f} commit should be mapped to a sequence of revision r6, r7 and r8 instead of one single revision. It needs an extension of suggested commit to revision mapping.
\end{enumerate}

Shelve linearization could be applied to any branch to keep history linear. But shelve is the most common use case.

\subsubsection{Nested Merge}

In this section we consider scenarios when revision or commit includes the merge history of another merges.

The first use case depicted at diagram \ref{nested_merge_full_mergeinfo_git_to_svn}. Commit \emph{i} is the merge commit of branches branch3 and branch1. But branch1 has a commit \emph{f} which is commit merged branch2 into branch1. For that case at corresponding revision r9 we add svn:mergeinfo property to branch3 which includes the merge history of all commits being merged at commit \emph{i}.

\begin{center}
\includegraphics[width=\textwidth]{img/diagrams/nested_merge_full_mergeinfo_git_to_svn.pdf}%
\captionof{figure}{Merge of Git branch which is available from another branch being translated to a sequence of Subversion revisions.}
\label{nested_merge_full_mergeinfo_git_to_svn}%
\end{center}

The mirror of this use case is depicted at diagram \ref{nested_merge_full_mergeinfo_svn_to_git}. Subversion user merged all the revision which represent the whole history of Git commits being merged at commit \emph{i}.

\begin{center}
\includegraphics[width=\textwidth]{img/diagrams/nested_merge_full_mergeinfo_svn_to_git.pdf}%
\captionof{figure}{Merge of Git branch which is available from another branch being translated to a sequence of Subversion revisions.}
\label{nested_merge_full_mergeinfo_svn_to_git}%
\end{center}

Slightly modified scenario is depicted at diagram \ref{nested_merge_partly_mergeinfo_svn_to_git}. Subversion user didn't include /branches/branch2@r5 into merge history explicitly. But this change already included via revision /branches/branch1@r6, thus commit \emph{e} is included into merge history of revision r9 implicitly. As result Translator is able to create commit \emph{i} corresponding to revision r9 and set two parents to it.

\begin{center}
\includegraphics[width=\textwidth]{img/diagrams/nested_merge_partly_mergeinfo_svn_to_git.pdf}%
\captionof{figure}{Merge of Git branch which is available from another branch being translated to a sequence of Subversion revisions.}
\label{nested_merge_partly_mergeinfo_svn_to_git}%
\end{center}

During Git to Subversion translation of merge commits Translator adds to svn:mergeinfo property all the revisions corresponding to commits appended to the history of branch by the merge. Another example of this translation introduced at diagram \ref{merge_sequence_git_to_svn}.

\begin{center}
\includegraphics[width=\textwidth]{img/diagrams/merge_sequence_git_to_svn.pdf}%
\captionof{figure}{Merge of Git branch which is available from another branch being translated to a sequence of Subversion revisions.}
\label{merge_sequence_git_to_svn}%
\end{center}

The same holds in opposite direction: when Subversion user merged revisions corresponding to commits which appended to the branch close the history of the branch, Translator creates merge commit which represents this change. This scenario is depicted at diagram \ref{merge_sequence_svn_to_git}.

\begin{center}
\includegraphics[width=\textwidth]{img/diagrams/merge_sequence_svn_to_git.pdf}%
\captionof{figure}{Merge of Git branch which is available from another branch being translated to a sequence of Subversion revisions.}
\label{merge_sequence_svn_to_git}%
\end{center}

Merged revisions may not include the whole history of certain branch. It is common case when Subversion user performed cherry-pick. As shown before Translator creates common commit for this case with single parent. This scenario is depicted at diagram \ref{no_merge_commit_cherry_pick_sequence_svn_to_git}.

\begin{center}
\includegraphics[width=\textwidth]{img/diagrams/no_merge_commit_cherry_pick_sequence_svn_to_git.pdf}%
\captionof{figure}{Merge of Git branch which is available from another branch being translated to a sequence of Subversion revisions.}
\label{no_merge_commit_cherry_pick_sequence_svn_to_git}%
\end{center}

\subsubsection{Octopus Merge}

Both Subversion and Git support \emph{octopus merge}, when an arbitrary number of branches being merged into the certain branch at single revision or commit. Translator supports this kind of history change as depicted at diagrams \ref{octopus_merge_git_to_svn} and \ref{octopus_merge_svn_to_git}.

\begin{center}
\includegraphics[width=\textwidth]{img/diagrams/octopus_merge_git_to_svn.pdf}%
\captionof{figure}{Octopus merge commit being translated to svn:mergeinfo change.}
\label{octopus_merge_git_to_svn}%
\end{center}

\begin{center}
\includegraphics[width=\textwidth]{img/diagrams/octopus_merge_svn_to_git.pdf}%
\captionof{figure}{Change of svn:mergeinfo property being translated to octopus merge commit.}
\label{octopus_merge_svn_to_git}%
\end{center}
